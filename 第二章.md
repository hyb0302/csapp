[toc]

# 笔记

## 信息存储

计算机访问数据是一次访问 8 位的块（1 byte）而不是一个 bit 一个 bit 访问的，意思就是访问的基本单位都是一个字节。

### 字数据大小

这里的字数据大小指的就是我们常说的 32 位系统或 64 位系统。

虚拟空间地址就是以一个字大小（word size）进行编码的

比如说现在有个 2 位操作系统，那虚拟地址空间为：0x00、0x01、0x10、0x11，共有4（![](https://latex.codecogs.com/svg.latex?2^2))个空间能存储数据，而计算机里可寻址的最小内存单位是一个字节（byte)，所以这个操作系统能支持的可用内存为 4 Byte。

所以这也解释了为什么以前说的 32 位操作系统只支持 4G 内存，如果内存是 8G 及以上要换成 64 位的系统。

32 位的操作系统共有 ![](https://latex.codecogs.com/svg.latex?2^{32})个可寻址的虚拟地址空间，也就是：![](https://latex.codecogs.com/svg.latex?2^{32}B=2^{22}KB=2^{12}MB=2^{2}GB=4GB)。

### 寻址和字节顺序

对于程序里的数据，会涉及到一些跨多个字节存储的对象，例如 int 占 4 个字节。大部分计算机都是连续存储这多个字节数据，也就是地址都是紧挨着。

以整数 0x01234567 举例，最高有效字节是 0x01，最低有效字节是 0x67

排列这些字节数据有两种规则：

比如有个 int 数的 16 进制表示为 0x01234567（两个十六进制数代表一个字节），要存放到 0x100、0x101、0x102、0x103

- 大端法（big endian）

  起始地址存放的是最高有效字节，采用最高有效字节->最低有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 01    | 23    | 45    | 67    |

- 小端法（little endian）

  起始地址存放的是最低有效字节，采用最低有效字节->最高有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 67    | 45    | 23    | 01    |

可以看出大端和小端的含义指的是起始地址存放的是最高有效字节还是最低有效字节或者说这些字节的存储顺序不同。

### 位运算与逻辑运算

位运算符：&、|、^、~

逻辑运算符：||、&&、!

这两个运算符不同的地方在于逻辑运算符返回的是 0（FALSE） 或者 1（TRUE），而位运算符返回的结果则根据参数决定。

- **逻辑运算符返回的是 0（FALSE） 或者 1（TRUE）**

  逻辑运算符认为所有非零的参数都表示 1（TRUE），也就是说 1111 && 0001 返回的结果是 1。

- **位运算符返回的结果则根据参数决定**

  还是用上面的两个数 1111、0001 举例，使用位运算符 1111 & 0001 返回的结果是 0001，只有在参数都限制为 1 位数时，返回结果才和逻辑运算符一样。

## 整数表示

### 有符号数和无符号数之间的转换

大部分计算机都是用补码来表示有符号数。

在开始接下来的内容之前，要先熟记这几个数代表什么意思

-  ![](https://latex.codecogs.com/svg.latex?TMin_w)

  w 位 bit 的最小补码值

-  ![](https://latex.codecogs.com/svg.latex?TMax_w)

  w 位 bit 的最大补码值

-  ![](https://latex.codecogs.com/svg.latex?UMin_w)

  w 位 bit 的最小于无符号数，等于 0

-  ![](https://latex.codecogs.com/svg.latex?UMax_w)

  w 位 bit 的最大无符号数

在我看来，下面两种转换只是解读二进制码的含义不同，转换实际没有改变二进制码的值

#### 补码转换为无符号数 ![](https://latex.codecogs.com/svg.latex?T2U_w(x))

![](https://latex.codecogs.com/svg.latex?T2U_w(x)=\begin{cases}x+2^w,&x<0\\x,&x>=0\end{cases})

-  ![](https://latex.codecogs.com/svg.latex?x+2^w,x<0)

  在 x 小于 0 时，补码的最高位为1，对应的权重为 ![](https://latex.codecogs.com/svg.latex?-2^{w-1})，要转换为无符号数时，对应的最高位权重位 ![](https://latex.codecogs.com/svg.latex?2^{w-1})，而其他位都一样可以忽略。

  *为什么说可以省略呢，举例 x = 1011，w=4，无符号数 ![](https://latex.codecogs.com/svg.latex?1001=2^3+2^1+2^0=11) ，有符号数 ![](https://latex.codecogs.com/svg.latex?1011=-2^3+2^1+2^0=-5)，可以看出有符号数和无符号数在解读位模式上，只有最高位是不同的。*

  假设加上 y，无符号数和有符号数就能相等，求出 y 的值就是补码表示的有符号数转换为无符号数所需加上的值

  ![](https://latex.codecogs.com/svg.latex?\\-2^{w-1}+y=2^{w-1}\\y=2^{w-1}+2^{w-1}\\y=2^w)

  接上面的例子（w = 4，x = 1011），因为有符号数 1011 是 -5 < 0，所以![](https://latex.codecogs.com/svg.latex?-2^3+2^1+2^0+2^4=11)，这样就成功转换成无符号数了。

-  ![](https://latex.codecogs.com/svg.latex?x,x>=0)

  当 x >= 0 时，补码的最高位为 0，通过上面分析，补码与无符号数只在最高位计算上不同，所以当最高位为 0 时不用做计算。

#### 无符号数转换为补码







## 整数运算

### 无符号加法

### 补码加法





# 练习题

## 2.5

|      | 小端法 | 大端法 |
| ---- | ------ | ------ |
| A    | 21     | 87     |
| B    | 2143   | 8765   |
| C    | 214365 | 876543 |

## 2.6

A. 

0x00359141      0000 0000 0011 0101 1001 0001 0100 0001

0x4A564504      0100 1010 0101 0110 0100 0101 0000 0100



B. 有21位匹配

00000000001**101011001000101000001**

​    010010100**101011001000101000001**00

C.

## 2.7

61 62 63 64 65 66



## 2.8

~a 10010110

~b 10101010

a & b  01000001

a | b  01111101

a ^ b  00111100



##  2.9

A.

黑 111    白 000

蓝 110    黄 001

绿 101    红紫 010

蓝绿 100   红 011



B.

蓝色 | 绿色 = 001 | 010 = 011 蓝绿色

黄色 & 蓝绿色 = 110 & 011 = 010 绿色

红色 ^ 红紫色 = 100 ^ 101 = 001 蓝色



## 2.10

| 步骤   | *x             | *y             |
| ------ | -------------- | -------------- |
| 初始   | a              | b              |
| 第一步 | a              | a ^ b          |
| 第二步 | a ^ a ^ b => b | a ^ b          |
| 第三步 | b              | a ^ b ^ b => a |



## 2.11

A. 都是K

B. 因为两个同样的数字进行异或运算，结果就是 0

C. first <= last 改成 first < last



## 2.12

A. x & 0xFF

B. x ^ (~0xFF)

利用【跟1异或就是取反】【跟0异或就是原值】的思路

C. x | 0xFF



## 2.13

这里让我不解的是异或的实现，其实是我不知道 x ^ y = (x & ~y) or (~x & y)

```c
  1 #include <stdio.h>
  2
  3 int bis(int x, int m) {
  4     return x | m;
  5 }
  6
  7 int bic(int x, int m) {
  8     return x & (~m);
  9 }
 10
 11 int bool_or(int x, int y) {
 12     return bis(x, y);
 13 }
 14
 15 int bool_xor(int x, int y) {
 16     return bis(bic(x, y), bic(y, x));
 17 }
```



## 2.14

x=0x66

0110 0110

y=0x39

0011 1001

| 表达式   | 值   | 表达式     | 值   |
| -------- | ---- | ---------- | ---- |
| x & y    | 0x20 | x && y     | 0x01 |
| x \| y   | 0x7F | x \|\| y   | 0x01 |
| ~x \| ~y | 0xDF | !x \|\| !y | 0x00 |
| x & !y   | 0x00 | x && ~y    | 0x01 |



## 2.15

!(x ^ y)



## 2.16

| x        |           | x << 3    |          | x >> 2(逻辑的) |          | x >> 2 (算数的) |          |
| -------- | --------- | --------- | -------- | -------------- | -------- | --------------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制         | 十六进制 | 二进制          | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000      | 0x30     | 1111 0000       | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101      | 0x1D     | 0001 1101       | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001      | 0x21     | 1110 0001       | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001      | 0x19     | 0001 1001       | 0x19     |



## 2.17




| $\overrightarrow{x}$ |        | B2U<sub>4</sub>($\overrightarrow{x}$) | B2T<sub>4</sub>($\overrightarrow{x}$) |
| -------------------- | ------ | ------------------------------------- | ------------------------------------- |
| 十六进制             | 二进制 |                                       |                                       |
| 0xE                  | [1110] | $2^3$                                 |                                       |
| 0x0                  |        |                                       |                                       |
| 0x5                  |        |                                       |                                       |
| 0x8                  |        |                                       |                                       |
| 0xD                  |        |                                       |                                       |
| 0xF                  |        |                                       |                                       |

