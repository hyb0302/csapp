[toc]

# 笔记

## 信息存储

计算机访问数据是一次访问 8 位的块（1 byte）而不是一个 bit 一个 bit 访问的，意思就是访问的基本单位都是一个字节。

### 字数据大小

这里的字数据大小指的就是我们常说的 32 位系统或 64 位系统。

虚拟空间地址就是以一个字大小（word size）进行编码的

比如说现在有个 2 位操作系统，那虚拟地址空间为：0x00、0x01、0x10、0x11，共有4（![](https://latex.codecogs.com/svg.latex?2^2))个空间能存储数据，而计算机里可寻址的最小内存单位是一个字节（byte)，所以这个操作系统能支持的可用内存为 4 Byte。

所以这也解释了为什么以前说的 32 位操作系统只支持 4G 内存，如果内存是 8G 及以上要换成 64 位的系统。

32 位的操作系统共有 ![](https://latex.codecogs.com/svg.latex?2^{32})个可寻址的虚拟地址空间，也就是：![](https://latex.codecogs.com/svg.latex?2^{32}B=2^{22}KB=2^{12}MB=2^{2}GB=4GB)。

### 寻址和字节顺序

对于程序里的数据，会涉及到一些跨多个字节存储的对象，例如 int 占 4 个字节。大部分计算机都是连续存储这多个字节数据，也就是地址都是紧挨着。

以整数 0x01234567 举例，最高有效字节是 0x01，最低有效字节是 0x67

排列这些字节数据有两种规则：

比如有个 int 数的 16 进制表示为 0x01234567（两个十六进制数代表一个字节），要存放到 0x100、0x101、0x102、0x103

- 大端法（big endian）

  起始地址存放的是最高有效字节，采用最高有效字节->最低有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 01    | 23    | 45    | 67    |

- 小端法（little endian）

  起始地址存放的是最低有效字节，采用最低有效字节->最高有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 67    | 45    | 23    | 01    |

可以看出大端和小端的含义指的是起始地址存放的是最高有效字节还是最低有效字节或者说这些字节的存储顺序不同。

### 位运算与逻辑运算

位运算符：&、|、^、~

逻辑运算符：||、&&、!

这两个运算符不同的地方在于逻辑运算符返回的是 0（FALSE） 或者 1（TRUE），而位运算符返回的结果则根据参数决定。

- **逻辑运算符返回的是 0（FALSE） 或者 1（TRUE）**

  逻辑运算符认为所有非零的参数都表示 1（TRUE），也就是说 1111 && 0001 返回的结果是 1。

- **位运算符返回的结果则根据参数决定**

  还是用上面的两个数 1111、0001 举例，使用位运算符 1111 & 0001 返回的结果是 0001，只有在参数都限制为 1 位数时，返回结果才和逻辑运算符一样。

## 整数表示

### 有符号数和无符号数之间的转换

大部分计算机都是用补码来表示有符号数。

在开始接下来的内容之前，要先熟记这几个数代表什么意思

-  ![](https://latex.codecogs.com/svg.latex?TMin_w)

  w 位 bit 的最小补码值

-  ![](https://latex.codecogs.com/svg.latex?TMax_w)

  w 位 bit 的最大补码值

-  ![](https://latex.codecogs.com/svg.latex?UMin_w)

  w 位 bit 的最小于无符号数，等于 0

-  ![](https://latex.codecogs.com/svg.latex?UMax_w)

  w 位 bit 的最大无符号数

在我看来，下面两种转换只是解读二进制码的含义不同，转换实际没有改变二进制码的值

#### 补码转换为无符号数 ![](https://latex.codecogs.com/svg.latex?T2U_w(x))

![](https://latex.codecogs.com/svg.latex?T2U_w(x)=\begin{cases}x+2^w,&x<0\\x,&x>=0\end{cases})

- ![](https://latex.codecogs.com/svg.latex?x+2^w,x<0)

  在 x 小于 0 时，补码的最高位为1，对应的权重为 ![](https://latex.codecogs.com/svg.latex?-2^{w-1})，要转换为无符号数时，对应的最高位权重位 ![](https://latex.codecogs.com/svg.latex?2^{w-1})，而其他位都一样可以忽略。

  *为什么说可以省略呢，举例 x = 1011，w=4，无符号数 ![](https://latex.codecogs.com/svg.latex?1001=2^3+2^1+2^0=11) ，有符号数 ![](https://latex.codecogs.com/svg.latex?1011=-2^3+2^1+2^0=-5)，可以看出有符号数和无符号数在解读位模式上，只有最高位是不同的。*

  假设加上 y，无符号数和有符号数就能相等，求出 y 的值就是补码表示的有符号数转换为无符号数所需加上的值

  ![](https://latex.codecogs.com/svg.latex?\\-2^{w-1}+y=2^{w-1}\\y=2^{w-1}+2^{w-1}\\y=2^w)

  接上面的例子（w = 4，x = 1011），因为有符号数 1011 是 -5 < 0，所以![](https://latex.codecogs.com/svg.latex?-2^3+2^1+2^0+2^4=11)，这样就成功转换成无符号数了。

  

  为什么会是2<sup>w</sup>呢？这里有一点新想法。

  因为最高有效位原来的权重是 -2<sup>w-1</sup>，转变成无符号数之后变成了2<sup>w-1</sup>

  从-2<sup>w-1</sup>到2<sup>w-1</sup>之间，需要-2<sup>w-1</sup> + 2<sup>w-1</sup> = 0，然后 0 + 2<sup>w-1</sup> = 2<sup>w-1</sup>

  加了两次 2<sup>w-1</sup>，结果就是 2<sup>w</sup>

  

-  ![](https://latex.codecogs.com/svg.latex?x,x>=0)

  当 x >= 0 时，补码的最高位为 0，通过上面分析，补码与无符号数只在最高位计算上不同，所以当最高位为 0 时不用做计算。

#### 无符号数转换为补码



#### 拓展数字的位表示

如果是拓展无符号数，则是在新拓展出的位补0，这种是零拓展

拓展有符号数，新拓展出的位则是补原来的符号位，这是符号拓展

#### 截断数字

将一种占用位数多的转换成占用位数少的数据类型，就会截断，比如 int 转成 short

这种截断会直接舍弃高位，然后再根据有符号数或者无符号数来解析这个二进制数



## 整数运算

无符号加法和补码加法的和都有可能超出自身长度限制，超出之后就舍弃多出来的那位，剩下的按照无符号数或者补码解析。

### 无符号加法

### 补码加法











# 练习题

## 2.5

|      | 小端法 | 大端法 |
| ---- | ------ | ------ |
| A    | 21     | 87     |
| B    | 2143   | 8765   |
| C    | 214365 | 876543 |

## 2.6

A. 

0x00359141      0000 0000 0011 0101 1001 0001 0100 0001

0x4A564504      0100 1010 0101 0110 0100 0101 0000 0100



B. 有21位匹配

00000000001**101011001000101000001**

​    010010100**101011001000101000001**00

C.

## 2.7

61 62 63 64 65 66



## 2.8

~a 10010110

~b 10101010

a & b  01000001

a | b  01111101

a ^ b  00111100



##  2.9

A.

黑 111    白 000

蓝 110    黄 001

绿 101    红紫 010

蓝绿 100   红 011



B.

蓝色 | 绿色 = 001 | 010 = 011 蓝绿色

黄色 & 蓝绿色 = 110 & 011 = 010 绿色

红色 ^ 红紫色 = 100 ^ 101 = 001 蓝色



## 2.10

| 步骤   | *x             | *y             |
| ------ | -------------- | -------------- |
| 初始   | a              | b              |
| 第一步 | a              | a ^ b          |
| 第二步 | a ^ a ^ b => b | a ^ b          |
| 第三步 | b              | a ^ b ^ b => a |



## 2.11

A. 都是K

B. 因为两个同样的数字进行异或运算，结果就是 0

C. first <= last 改成 first < last



## 2.12

A. x & 0xFF

B. x ^ (~0xFF)

利用【跟1异或就是取反】【跟0异或就是原值】的思路

C. x | 0xFF



## 2.13

这里让我不解的是异或的实现，其实是我不知道 x ^ y = (x & ~y) or (~x & y)

```c
  1 #include <stdio.h>
  2
  3 int bis(int x, int m) {
  4     return x | m;
  5 }
  6
  7 int bic(int x, int m) {
  8     return x & (~m);
  9 }
 10
 11 int bool_or(int x, int y) {
 12     return bis(x, y);
 13 }
 14
 15 int bool_xor(int x, int y) {
 16     return bis(bic(x, y), bic(y, x));
 17 }
```



## 2.14

x=0x66

0110 0110

y=0x39

0011 1001

| 表达式   | 值   | 表达式     | 值   |
| -------- | ---- | ---------- | ---- |
| x & y    | 0x20 | x && y     | 0x01 |
| x \| y   | 0x7F | x \|\| y   | 0x01 |
| ~x \| ~y | 0xDF | !x \|\| !y | 0x00 |
| x & !y   | 0x00 | x && ~y    | 0x01 |



## 2.15

!(x ^ y)



## 2.16

| x        |           | x << 3    |          | x >> 2(逻辑的) |          | x >> 2 (算数的) |          |
| -------- | --------- | --------- | -------- | -------------- | -------- | --------------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制         | 十六进制 | 二进制          | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000      | 0x30     | 1111 0000       | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101      | 0x1D     | 0001 1101       | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001      | 0x21     | 1110 0001       | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001      | 0x19     | 0001 1001       | 0x19     |



## 2.17




| $\overrightarrow{x}$ |        | B2U<sub>4</sub>($\overrightarrow{x}$)                        | B2T<sub>4</sub>($\overrightarrow{x}$)                        |
| -------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 十六进制             | 二进制 |                                                              |                                                              |
| 0xE                  | [1110] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> = 14           | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> = -2          |
| 0x0                  | [0000] | 0                                                            | 0                                                            |
| 0x5                  | [0101] | 2<sup>2</sup> + 2<sup>0</sup> = 5                            | 2<sup>2</sup> + 2<sup>0</sup> = 5                            |
| 0x8                  | [1000] | 2<sup>3</sup> = 8                                            | -2<sup>3</sup> = -8                                          |
| 0xD                  | [1101] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> = 13           | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> = -3          |
| 0xF                  | [1111] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = 15 | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -1 |



## 2.18

A. 0x2e0 => 0010 1110 0000 => 512+128+64+32 =   736

B. -0x58 => 0101 1000 = -88

C. 0x28 => 0010 1000 => 40

D. -0x30 => 0011 0000 => -48

E. 0x78 => 0111 1000 => 120

F. 0x88 => 1000 1000 => 136

G. 0x1f8 => 0001 1111 1000 => 504

H. 0xc0 => 1100 0000 => 192

I. -0x48 => 0100 1000 => -72



## 2.19

| x    | T2U<sub>4</sub>(x) |
| ---- | ------------------ |
| -8   | 1000 => 8          |
| -3   | 1101 => 13         |
| -2   | 1110 => 14         |
| -1   | 1111 => 15         |
| 0    | 0000 => 0          |
| 5    | 0101 => 5          |



## 2.20

| x    | T2U<sub>4</sub>(x) |
| ---- | ------------------ |
| -8   | -8 + 16 => 8       |
| -3   | -3 + 16 => 13      |
| -2   | -2 + 16 =>  14     |
| -1   | -1 + 16 => 15      |
| 0    | 0 => 0             |
| 5    | 5 => 5             |



## 2.21

2147483647 = 2<sup>31</sup> - 1

2147483648 = 2<sup>31</sup>

| 表达式                         | 类型   | 求值 |
| ------------------------------ | ------ | ---- |
| -2147483647 - 1 == 2147483648U | 无符号 | 1*   |
| -2147483647 - 1 < 2147483647   | 有符号 | 1    |
| -2147483647 - 1U < 2147483647  | 无符号 | 0*   |
| -2147483647 - 1 < -2147483647  | 有符号 | 1    |
| -2147483647 - 1U < -2147483647 | 无符号 | 1    |



## 2.22

A. [1011]

-2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5

B. [11011]

-2<sup>4</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5

C. [111011]

-2<sup>5 </sup>+ 2<sup>4</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5



## 2.23

A. 

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |

B. 



## 2.24

| 十六进制 |        | 无符号 |        | 补码   |        |
| -------- | ------ | ------ | ------ | ------ | ------ |
| 原始值   | 截断值 | 原始值 | 截断值 | 原始值 | 截断值 |
| 0        | 0      | 0      | 0      | 0      | 0      |
| 2        | 2      | 2      | 0      | 2      | 2      |
| 9        | 1      | 9      | 1      | -7     | 1      |
| B        | 3      | 11     | 3      | -5     | 3      |
| F        | 7      | 15     | 7      | -1     | -1     |



## 2.25

length 是无符号的类型，当 length = 0 时，在循环里判断 i <= length - 1，会变成无符号数之间的判断，这时候会变成 i <= 0xFFFFFFFF，造成内存错误

把 i <= length - 1 改成  i < length 就能解决这个 bug



## 2.26

A. s 的长度比 t 的长度短的时候会出错

B. 因为两个无符号数运算，得出来的也是无符号数，不会是负数

C. 改成 return strlen(s) > strlen(t);



## 2.27

```c
  3 int uadd_ok(unsigned x, unsigned y) {
  4     unsigned s = x + y;
  5     return s >= x && s >= y;
  6 }
```



## 2.28

| x        |        | -<sup>u</sup><sub>4</sub>x |          |
| -------- | ------ | -------------------------- | -------- |
| 十六进制 | 十进制 | 十进制                     | 十六进制 |
| 0        | 0      | 0                          | 0        |
| 5        | 5      | 11                         | B        |
| 8        | 8      | 8                          | 8        |
| D        | 13     | 3                          | 3        |
| F        | 15     | 1                          | 1        |



## 2.29

| x               | y                | x + y             | x+<sup>t</sup><sub>5</sub>y | 情况 |
| --------------- | ---------------- | ----------------- | --------------------------- | ---- |
| -12<br/>[10100] | -15<br />[10001] | -27<br />[100101] | 5<br />[00101]              | 1    |
| -8<br />[11000] | -8<br />[11000]  | -16<br />[110000] | -16<br />[10000]            | 2    |
| -9<br />[10111] | 8<br />[01000]   | -1<br />[11111]   | -1<br />[11111]             | 2    |
| 2<br />[00010]  | 5<br />[00101]   | 7<br />[00111]    | 7<br />[00111]              | 3    |
| 12<br />[01100] | 4<br />[00100]   | -16<br />[10000]  | -16<br />[10000]            | 4    |



## 2.30

```c
int tadd_ok(int x, int y) {
    int s = x + y;
    if (x >= 0 && y >= 0) {
        return s >= 0;
    }
    if (x < 0 && y < 0) {
        return s < 0;
    }
    return 1;
}
```



## 2.31

在两个数都取最小负数的时候，会检测不出来已经负溢出了

这里为了方便，假设 int 只有 4 位二进制数表示

此时 x 和 y 都是最小负数 -8（1000）

x + y 的和 sum 的值就是 10000，因为只有 4 位，丢弃高位后就是 0000

这时 sum - x == y 代入数字就变成 0000 - 1000 == 1000

减去一个数等于加上这个数的补数（取反加一），因为 1000 的补数还是 1000

所以式子变成 0000 + 1000 == 1000，返回就是 1

sum - y == x 跟上面是同样的逻辑，因此在两个数都取最小负数的时候，会检测不出来已经负溢出了

```c
#include <stdio.h>
 
int tadd_ok(int x, int y) {
    int sum = x + y;
    return (sum - x == y) && (sum - y == x);
}
 
int main() {
    printf("%d\n", tadd_ok(0x80000000, 0x80000000));
    printf("%d\n", tadd_ok(0x7FFFFFFF, 0x7FFFFFFF));
}
```

最后我发现不管取什么值，都是上面这个逻辑，得再仔细研究下
