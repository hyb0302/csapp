[toc]

# 笔记

## 信息存储

计算机访问数据是一次访问 8 位的块（1 byte）而不是一个 bit 一个 bit 访问的，意思就是访问的基本单位都是一个字节。

### 字数据大小

这里的字数据大小指的就是我们常说的 32 位系统或 64 位系统。

虚拟空间地址就是以一个字大小（word size）进行编码的

比如说现在有个 2 位操作系统，那虚拟地址空间为：0x00、0x01、0x10、0x11，共有4（![](https://latex.codecogs.com/svg.latex?2^2))个空间能存储数据，而计算机里可寻址的最小内存单位是一个字节（byte)，所以这个操作系统能支持的可用内存为 4 Byte。

所以这也解释了为什么以前说的 32 位操作系统只支持 4G 内存，如果内存是 8G 及以上要换成 64 位的系统。

32 位的操作系统共有 ![](https://latex.codecogs.com/svg.latex?2^{32})个可寻址的虚拟地址空间，也就是：![](https://latex.codecogs.com/svg.latex?2^{32}B=2^{22}KB=2^{12}MB=2^{2}GB=4GB)。

### 寻址和字节顺序

对于程序里的数据，会涉及到一些跨多个字节存储的对象，例如 int 占 4 个字节。大部分计算机都是连续存储这多个字节数据，也就是地址都是紧挨着。

以整数 0x01234567 举例，最高有效字节是 0x01，最低有效字节是 0x67

排列这些字节数据有两种规则：

比如有个 int 数的 16 进制表示为 0x01234567（两个十六进制数代表一个字节），要存放到 0x100、0x101、0x102、0x103

- 大端法（big endian）

  起始地址存放的是最高有效字节，采用最高有效字节->最低有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 01    | 23    | 45    | 67    |

- 小端法（little endian）

  起始地址存放的是最低有效字节，采用最低有效字节->最高有效字节的顺序存储

  | 0x100 | 0x101 | 0x102 | 0x103 |
  | ----- | ----- | ----- | ----- |
  | 67    | 45    | 23    | 01    |

可以看出大端和小端的含义指的是起始地址存放的是最高有效字节还是最低有效字节或者说这些字节的存储顺序不同。

### 位运算与逻辑运算

位运算符：&、|、^、~

逻辑运算符：||、&&、!

这两个运算符不同的地方在于逻辑运算符返回的是 0（FALSE） 或者 1（TRUE），而位运算符返回的结果则根据参数决定。

- **逻辑运算符返回的是 0（FALSE） 或者 1（TRUE）**

  逻辑运算符认为所有非零的参数都表示 1（TRUE），也就是说 1111 && 0001 返回的结果是 1。

- **位运算符返回的结果则根据参数决定**

  还是用上面的两个数 1111、0001 举例，使用位运算符 1111 & 0001 返回的结果是 0001，只有在参数都限制为 1 位数时，返回结果才和逻辑运算符一样。

## 整数表示

### 有符号数和无符号数之间的转换

大部分计算机都是用补码来表示有符号数。

在开始接下来的内容之前，要先熟记这几个数代表什么意思

-  ![](https://latex.codecogs.com/svg.latex?TMin_w)

  w 位 bit 的最小补码值

-  ![](https://latex.codecogs.com/svg.latex?TMax_w)

  w 位 bit 的最大补码值

-  ![](https://latex.codecogs.com/svg.latex?UMin_w)

  w 位 bit 的最小于无符号数，等于 0

-  ![](https://latex.codecogs.com/svg.latex?UMax_w)

  w 位 bit 的最大无符号数

在我看来，下面两种转换只是解读二进制码的含义不同，转换实际没有改变二进制码的值

#### 补码转换为无符号数 ![](https://latex.codecogs.com/svg.latex?T2U_w(x))

![](https://latex.codecogs.com/svg.latex?T2U_w(x)=\begin{cases}x+2^w,&x<0\\x,&x>=0\end{cases})

- ![](https://latex.codecogs.com/svg.latex?x+2^w,x<0)

  在 x 小于 0 时，补码的最高位为1，对应的权重为 ![](https://latex.codecogs.com/svg.latex?-2^{w-1})，要转换为无符号数时，对应的最高位权重位 ![](https://latex.codecogs.com/svg.latex?2^{w-1})，而其他位都一样可以忽略。

  *为什么说可以省略呢，举例 x = 1011，w=4，无符号数 ![](https://latex.codecogs.com/svg.latex?1001=2^3+2^1+2^0=11) ，有符号数 ![](https://latex.codecogs.com/svg.latex?1011=-2^3+2^1+2^0=-5)，可以看出有符号数和无符号数在解读位模式上，只有最高位是不同的。*

  假设加上 y，无符号数和有符号数就能相等，求出 y 的值就是补码表示的有符号数转换为无符号数所需加上的值

  ![](https://latex.codecogs.com/svg.latex?\\-2^{w-1}+y=2^{w-1}\\y=2^{w-1}+2^{w-1}\\y=2^w)

  接上面的例子（w = 4，x = 1011），因为有符号数 1011 是 -5 < 0，所以![](https://latex.codecogs.com/svg.latex?-2^3+2^1+2^0+2^4=11)，这样就成功转换成无符号数了。

  

  为什么会是2<sup>w</sup>呢？这里有一点新想法。

  因为最高有效位原来的权重是 -2<sup>w-1</sup>，转变成无符号数之后变成了2<sup>w-1</sup>

  从-2<sup>w-1</sup>到2<sup>w-1</sup>之间，需要-2<sup>w-1</sup> + 2<sup>w-1</sup> = 0，然后 0 + 2<sup>w-1</sup> = 2<sup>w-1</sup>

  加了两次 2<sup>w-1</sup>，结果就是 2<sup>w</sup>

  

-  ![](https://latex.codecogs.com/svg.latex?x,x>=0)

  当 x >= 0 时，补码的最高位为 0，通过上面分析，补码与无符号数只在最高位计算上不同，所以当最高位为 0 时不用做计算。

#### 无符号数转换为补码



#### 拓展数字的位表示

如果是拓展无符号数，则是在新拓展出的位补0，这种是零拓展

拓展有符号数，新拓展出的位则是补原来的符号位，这是符号拓展

#### 截断数字

将一种占用位数多的转换成占用位数少的数据类型，就会截断，比如 int 转成 short

这种截断会直接舍弃高位，然后再根据有符号数或者无符号数来解析这个二进制数



## 整数运算

无符号加法和补码加法的和都有可能超出自身长度限制，超出之后就舍弃多出来的那位，剩下的按照无符号数或者补码解析。

### 无符号加法

### 补码加法



### 补码乘法

补码乘法怎么得到就结果的二进制串，有两种方法，这里书上没提到

1. 乘之前先符号拓展到 2w 位，然后再进行乘法计算
2. 把负的值先取反加一转成正的，进行计算完，再对结果取反加一转回去



## 浮点数

### IEEE 浮点表示

V = (-1)<sup>s</sup> x M x 2<sup>E</sup>



- 符号（sign），用 s 来代表符号位，0 是正的，1 是负的

- 尾数（significand），用来决定小数值是什么的数，用 frac 代表尾数的位模式 frac = f<sub>n-1</sub>...f<sub>1</sub>f<sub>0</sub>

- 阶码（exponent），用来决定移动小数点到往左还是往右移几位的一个数，用 exp 来代表阶码的位模式 exp = e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>

  

从 V = (-1)<sup>s</sup> x M x 2<sup>E</sup> 这个形式来看

s 最终的值是本身的符号位数

M 的值是二进制小数，需要通过【尾数  frac】来编码。

*这里编码的意思是，只通过尾数 frac 的位模式得出的值不能就直接给 M 用，需要根据不同情况编码（不同的计算公式）*

E 的值要通过【阶码 exp】来编码



由这样看来

- 尾数，frac（n位） 用来编码 M
- 阶码，exp（k位） 用来编码 E



以下三种情况的值用单精度来举例，s = 1、k = 8, n = 23

#### 规格化的值

exp != 0 && exp != 255

这种情况下，阶码 exp 最小值是 1，最大值是 254，那么怎么编码 E 呢？

E = exp - Bias

上面说过 exp 是 k 位的位模式，exp 是解释为无符号数

那么 Bias 的值就是 2<sup>k-1 </sup>- 1 = 2 <sup>7 </sup> - 1 = 127，我觉得这里可以把 Bias 的值认为是 k 位二进制数的最大有符号数

1 - 127 <= E <= 254 - 127

所以 E 的取值范围就是 -126 ~ +127，-126 <= E <= 127



那么怎么编码尾数 M 呢？

M = 1.f<sub>n - 1</sub>...f<sub>1</sub>f<sub>0</sub>

也就是说类型是规格化的值，是不为 0 的



#### 非规格化的值

exp = 0

在这个类型里，编码阶码 E 就不是像规格化那样用 exp 减去 Bias 了

而是 E = 1 - Bias，这里的 Bias 的值跟规格化那里一样，在单精度下就是 127

那么在非规格化的值里，E = -126

为什么这里不是 E = 0 - Bias 呢？为了让规格化的值和非规格化的值可以平滑转变，具体例子可以看书中图 2-35



那这里怎么编码尾数 M 的呢？

M = frac

可以看出，相比于规格化的类型，这里少了隐含的 1 开头，可以表示 0 了

M = 0 的时候，E 的值不管是多少（也就是不管小数点挪到哪里），表示的浮点数的值就是 0

根据符号位的不同，有区分 +0.0 和 -0.0

因为 E 都等于 126，所以非规格化的值也可以用来表示很接近 0 的数



#### 特殊值

特殊值的特点就是 exp 全为 1

##### 无穷

exp = 1111 1111 && frac = 0

由符号位决定是正无穷还是负无穷

##### NaN （Not a Number）

exp = 1111 1111 && frac != 0

用来表示不是一个数值



# 练习题

## 2.5

|      | 小端法 | 大端法 |
| ---- | ------ | ------ |
| A    | 21     | 87     |
| B    | 2143   | 8765   |
| C    | 214365 | 876543 |

## 2.6

A. 

0x00359141      0000 0000 0011 0101 1001 0001 0100 0001

0x4A564504      0100 1010 0101 0110 0100 0101 0000 0100



B. 有21位匹配

00000000001**101011001000101000001**

​    010010100**101011001000101000001**00

C.

## 2.7

61 62 63 64 65 66



## 2.8

~a 10010110

~b 10101010

a & b  01000001

a | b  01111101

a ^ b  00111100



##  2.9

A.

黑 111    白 000

蓝 110    黄 001

绿 101    红紫 010

蓝绿 100   红 011



B.

蓝色 | 绿色 = 001 | 010 = 011 蓝绿色

黄色 & 蓝绿色 = 110 & 011 = 010 绿色

红色 ^ 红紫色 = 100 ^ 101 = 001 蓝色



## 2.10

| 步骤   | *x             | *y             |
| ------ | -------------- | -------------- |
| 初始   | a              | b              |
| 第一步 | a              | a ^ b          |
| 第二步 | a ^ a ^ b => b | a ^ b          |
| 第三步 | b              | a ^ b ^ b => a |



## 2.11

A. 都是K

B. 因为两个同样的数字进行异或运算，结果就是 0

C. first <= last 改成 first < last



## 2.12

A. x & 0xFF

B. x ^ (~0xFF)

利用【跟1异或就是取反】【跟0异或就是原值】的思路

C. x | 0xFF



## 2.13

这里让我不解的是异或的实现，其实是我不知道 x ^ y = (x & ~y) or (~x & y)

```c
  1 #include <stdio.h>
  2
  3 int bis(int x, int m) {
  4     return x | m;
  5 }
  6
  7 int bic(int x, int m) {
  8     return x & (~m);
  9 }
 10
 11 int bool_or(int x, int y) {
 12     return bis(x, y);
 13 }
 14
 15 int bool_xor(int x, int y) {
 16     return bis(bic(x, y), bic(y, x));
 17 }
```



## 2.14

x=0x66

0110 0110

y=0x39

0011 1001

| 表达式   | 值   | 表达式     | 值   |
| -------- | ---- | ---------- | ---- |
| x & y    | 0x20 | x && y     | 0x01 |
| x \| y   | 0x7F | x \|\| y   | 0x01 |
| ~x \| ~y | 0xDF | !x \|\| !y | 0x00 |
| x & !y   | 0x00 | x && ~y    | 0x01 |



## 2.15

!(x ^ y)



## 2.16

| x        |           | x << 3    |          | x >> 2(逻辑的) |          | x >> 2 (算数的) |          |
| -------- | --------- | --------- | -------- | -------------- | -------- | --------------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制         | 十六进制 | 二进制          | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000      | 0x30     | 1111 0000       | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101      | 0x1D     | 0001 1101       | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001      | 0x21     | 1110 0001       | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001      | 0x19     | 0001 1001       | 0x19     |



## 2.17




| $\overrightarrow{x}$ |        | B2U<sub>4</sub>($\overrightarrow{x}$)                        | B2T<sub>4</sub>($\overrightarrow{x}$)                        |
| -------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 十六进制             | 二进制 |                                                              |                                                              |
| 0xE                  | [1110] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> = 14           | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> = -2          |
| 0x0                  | [0000] | 0                                                            | 0                                                            |
| 0x5                  | [0101] | 2<sup>2</sup> + 2<sup>0</sup> = 5                            | 2<sup>2</sup> + 2<sup>0</sup> = 5                            |
| 0x8                  | [1000] | 2<sup>3</sup> = 8                                            | -2<sup>3</sup> = -8                                          |
| 0xD                  | [1101] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> = 13           | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> = -3          |
| 0xF                  | [1111] | 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = 15 | -2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -1 |



## 2.18

A. 0x2e0 => 0010 1110 0000 => 512+128+64+32 =   736

B. -0x58 => 0101 1000 = -88

C. 0x28 => 0010 1000 => 40

D. -0x30 => 0011 0000 => -48

E. 0x78 => 0111 1000 => 120

F. 0x88 => 1000 1000 => 136

G. 0x1f8 => 0001 1111 1000 => 504

H. 0xc0 => 1100 0000 => 192

I. -0x48 => 0100 1000 => -72



## 2.19

| x    | T2U<sub>4</sub>(x) |
| ---- | ------------------ |
| -8   | 1000 => 8          |
| -3   | 1101 => 13         |
| -2   | 1110 => 14         |
| -1   | 1111 => 15         |
| 0    | 0000 => 0          |
| 5    | 0101 => 5          |



## 2.20

| x    | T2U<sub>4</sub>(x) |
| ---- | ------------------ |
| -8   | -8 + 16 => 8       |
| -3   | -3 + 16 => 13      |
| -2   | -2 + 16 =>  14     |
| -1   | -1 + 16 => 15      |
| 0    | 0 => 0             |
| 5    | 5 => 5             |



## 2.21

2147483647 = 2<sup>31</sup> - 1

2147483648 = 2<sup>31</sup>

| 表达式                         | 类型   | 求值 |
| ------------------------------ | ------ | ---- |
| -2147483647 - 1 == 2147483648U | 无符号 | 1*   |
| -2147483647 - 1 < 2147483647   | 有符号 | 1    |
| -2147483647 - 1U < 2147483647  | 无符号 | 0*   |
| -2147483647 - 1 < -2147483647  | 有符号 | 1    |
| -2147483647 - 1U < -2147483647 | 无符号 | 1    |



## 2.22

A. [1011]

-2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5

B. [11011]

-2<sup>4</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5

C. [111011]

-2<sup>5 </sup>+ 2<sup>4</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -5



## 2.23

A. 

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |

B. 



## 2.24

| 十六进制 |        | 无符号 |        | 补码   |        |
| -------- | ------ | ------ | ------ | ------ | ------ |
| 原始值   | 截断值 | 原始值 | 截断值 | 原始值 | 截断值 |
| 0        | 0      | 0      | 0      | 0      | 0      |
| 2        | 2      | 2      | 0      | 2      | 2      |
| 9        | 1      | 9      | 1      | -7     | 1      |
| B        | 3      | 11     | 3      | -5     | 3      |
| F        | 7      | 15     | 7      | -1     | -1     |



## 2.25

length 是无符号的类型，当 length = 0 时，在循环里判断 i <= length - 1，会变成无符号数之间的判断，这时候会变成 i <= 0xFFFFFFFF，造成内存错误

把 i <= length - 1 改成  i < length 就能解决这个 bug



## 2.26

A. s 的长度比 t 的长度短的时候会出错

B. 因为两个无符号数运算，得出来的也是无符号数，不会是负数

C. 改成 return strlen(s) > strlen(t);



## 2.27

```c
  3 int uadd_ok(unsigned x, unsigned y) {
  4     unsigned s = x + y;
  5     return s >= x && s >= y;
  6 }
```



## 2.28

| x        |        | -<sup>u</sup><sub>4</sub>x |          |
| -------- | ------ | -------------------------- | -------- |
| 十六进制 | 十进制 | 十进制                     | 十六进制 |
| 0        | 0      | 0                          | 0        |
| 5        | 5      | 11                         | B        |
| 8        | 8      | 8                          | 8        |
| D        | 13     | 3                          | 3        |
| F        | 15     | 1                          | 1        |



## 2.29

| x               | y                | x + y             | x+<sup>t</sup><sub>5</sub>y | 情况 |
| --------------- | ---------------- | ----------------- | --------------------------- | ---- |
| -12<br/>[10100] | -15<br />[10001] | -27<br />[100101] | 5<br />[00101]              | 1    |
| -8<br />[11000] | -8<br />[11000]  | -16<br />[110000] | -16<br />[10000]            | 2    |
| -9<br />[10111] | 8<br />[01000]   | -1<br />[11111]   | -1<br />[11111]             | 2    |
| 2<br />[00010]  | 5<br />[00101]   | 7<br />[00111]    | 7<br />[00111]              | 3    |
| 12<br />[01100] | 4<br />[00100]   | -16<br />[10000]  | -16<br />[10000]            | 4    |



## 2.30

```c
int tadd_ok(int x, int y) {
    int s = x + y;
    if (x >= 0 && y >= 0) {
        return s >= 0;
    }
    if (x < 0 && y < 0) {
        return s < 0;
    }
    return 1;
}
```



## 2.31

在两个数都取最小负数的时候，会检测不出来已经负溢出了

这里为了方便，假设 int 只有 4 位二进制数表示

此时 x 和 y 都是最小负数 -8（1000）

x + y 的和 sum 的值就是 10000，因为只有 4 位，丢弃高位后就是 0000

这时 sum - x == y 代入数字就变成 0000 - 1000 == 1000

减去一个数等于加上这个数的补数（取反加一），因为 1000 的补数还是 1000

所以式子变成 0000 + 1000 == 1000，返回就是 1

sum - y == x 跟上面是同样的逻辑，因此在两个数都取最小负数的时候，会检测不出来已经负溢出了

```c
#include <stdio.h>
 
int tadd_ok(int x, int y) {
    int sum = x + y;
    return (sum - x == y) && (sum - y == x);
}
 
int main() {
    printf("%d\n", tadd_ok(0x80000000, 0x80000000));
    printf("%d\n", tadd_ok(0x7FFFFFFF, 0x7FFFFFFF));
}
```

最后我发现不管取什么值，都是上面这个逻辑，得再仔细研究下



假设 int 为 4 位

溢出的情况

x = 0111,y = 0010,sum = 1001

sum - x == y,1001 + 1001 = 10010 == 0010

sum - y == x,1001 + 1110 = 10111 == 0111



没有溢出的情况

x = 0111,y = 1111,sum = 10110

sum - x == y,0110 + 1001 = 1111 == 1111
sum - y == x,0110 + 0001 = 0111 == 0111



可以看出， 按照这个同事的代码判断，溢出了也是返回1，判断不了溢出



## 2.32

在 y 取最小负数的时候会产生错误的结果

为了简单起见，假设 int 是 4 位二进制数

x = 0001,y = 1000

此时 x - y = 1 - (-8) = 9，9 已经超出了 4 位二进制能表达的最大有符号数

但是这里传给 tadd_ok(x, -y) 的 -y，取的是 y 的补码，但由于 y 是最小负数，补码还是 1000，所以在 tadd_ok 里判断，x 为正数，y 为负数，所以判断不会溢出

```c
int tsub_ok(int x, int y) {
    if (y == 0x80000000) {
        if (x > 0) {
            return 0;
        } else {
            return 1;
        }
    }
    return tadd_ok(x, -y);
}
```



## 2.33

| x        |        | -<sup>t</sup><sub>4</sub>x |          |
| -------- | ------ | -------------------------- | -------- |
| 十六进制 | 十进制 | 十进制                     | 十六进制 |
| 0        | 0      | 0                          | 0        |
| 5        | 5      | -5                         | B        |
| 8        | -8     | -8                         | 8        |
| D        | -3     | 3                          | 3        |
| F        | -1     | 1                          | 1        |



## 2.34

| 模式   | x     | y     | x*y      | 截断的x*y |
| ------ | ----- | ----- | -------- | --------- |
| 无符号 | [100] | [101] | [010100] | [100]     |
| 补码   | [100] | [101] | [001100] | [100]     |
| 无符号 | [010] | [111] | [001110] | [110]     |
| 补码   | [010] | [111] | [111110] | [110]     |
| 无符号 | [110] | [110] | [100100] | [100]     |
| 补码   | [110] | [110] | [000100] | [100]     |



## 2.35

有点看不懂，等状态好的时候再看



## 2.36

```c
#include <stdio.h>
#include <inttypes.h>
#include <string.h>

int tmult_ok(int x, int y) {
    int64_t s = (int64_t)x * y;
    show_int64(s);
    return s == (int)s;
}

int main(int argc, char* args[]) {
    int x = atoi(args[1]);
    int y = atoi(args[2]);
    printf("arg 1:%d\n", x);
    printf("arg 2:%d\n", y);
    printf("%d\n", tmult_ok(x, y));
}
```



## 2.37

A. 换成无符号数，其实就是可分配空间更大了，但实际上还是有可能溢出

B. 改进就是判断是否溢出，如果溢出了就返回空，分配失败

书里的答案说 malloc 的参数是 32 位无符号数，所以可以通过判断强制转换后是否一样判断是否溢出

```c
uint64_t asize = ele_cnt * (uint64_t) ele_size;
if (asize != (int)asize) {
    return NULL;
}
```

但是我电脑上看我的 malloc 函数，参数是 size_t = unsigned long long

这时候应该怎么判断溢出呢？

利用 sum = a * b，a != 0 && sum / a != b 这个表达式可以判断溢出

```c
int asize = ele_cnt * ele_size;
if (ele_cnt != 0 && asize / ele_cnt != ele_size) {
    return NULL;
}
```



## 2.38

可以计算出 2<sup>k</sup> 或者 2<sup>k</sup> + 1 倍



## 2.42

```c
int div16(int x) {
    int bias = x >> 31 & 0xF;
    return (x + bias) >> 4;
}
```



## 2.43

x = x * 2<sup>5</sup> - x * 2<sup>0</sup>

y = y / 8

M = 31,N=8



## 2.44

A. x = 0x80000000

B. 真，当 (x & 7 != 7) 这个结果如果为 0，那就代表 x & 7 == 7，x<sub>2</sub>就一定为1，那这样左移29位后，这个就是符号位，整个结果是负数，那就 x << 29 < 0 就为1，所以不可能出现两个条件都是0的情况 

C. 当 x = 0xFFFF0 

D. 真

E. 假，x = 0x80000000

F. 真

G. 真 

-y = ~y + 1

~y = -y - 1



x * ~y + uy * ux == -x

x * (-y - 1) + x * y == -x

x * -y - x + x * y == -x

x * (-y - 1 + y) == -x

x * -1 == -x



## 2.45

| 小数值 | 二进制  | 十进制 |
| ------ | ------- | ------ |
| 1/8    | 0.001   | 0.125  |
| 3/4    | 0.11    | 0.75   |
| 25/16  | 1.1001  | 1.5625 |
| 43/16  | 10.1011 | 2.6875 |
| 9/8    | 1.001   | 1.125  |
| 47/8   | 101.111 | 5.875  |
| 51/16  | 11.0011 | 3.1875 |



## 2.46

A. 0.{23个0}1100[1100]

B. 0.0000000894

C. 0.3218

D. 0.3218 * 2000 = 643.6米



## 2.47

| 位      | e    | E    | 2<sup>E</sup> | f    | M    | 2<sup>E</sup> x M | V        | 十进制 |
| ------- | ---- | ---- | ------------- | ---- | ---- | ----------------- | -------- | ------ |
| 0 00 00 | 0    | 0    | 1             | 0    | 0    | 0                 | 0        | 0      |
| 0 00 01 | 0    | 0    | 1             | 1/4  | 1/4  | 1/4               | 1/4      | 0.25   |
| 0 00 10 | 0    | 0    | 1             | 1/2  | 1/2  | 1/2               | 1/2      | 0.5    |
| 0 00 11 | 0    | 0    | 1             | 3/4  | 3/4  | 3/4               | 3/4      | 0.75   |
| 0 01 00 | 1    | 0    | 1             | 0    | 1    | 1                 | 1        | 1      |
| 0 01 01 | 1    | 0    | 1             | 1/4  | 5/4  | 5/4               | 5/4      | 1.25   |
| 0 01 10 | 1    | 0    | 1             | 1/2  | 3/2  | 3/2               | 3/2      | 1.5    |
| 0 01 11 | 1    | 0    | 1             | 3/4  | 7/4  | 7/4               | 7/4      | 1.75   |
| 0 10 00 | 2    | 1    | 2             | 0    | 1    | 2                 | 2        | 2      |
| 0 10 01 | 2    | 1    | 2             | 1/4  | 5/4  | 10/4              | 5/2      | 2.5    |
| 0 10 10 | 2    | 1    | 2             | 1/2  | 3/2  | 3                 | 3        | 3      |
| 0 10 11 | 2    | 1    | 2             | 3/4  | 7/4  | 7/2               | 7/2      | 3.5    |
| 0 11 00 | -    | -    | -             | -    | -    | -                 | 正无穷大 | -      |
| 0 11 01 | -    | -    | -             | -    | -    | -                 | NaN      | -      |
| 0 11 10 | -    | -    | -             | -    | -    | -                 | NaN      | -      |
| 0 11 11 | -    | -    | -             | -    | -    | -                 | NaN      | -      |



## 2.48

0x00359141

0x4A564504

0000 0000 0011 0101 1001 0001 1000 0001



