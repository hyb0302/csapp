# 笔记

## 访问信息

### 数据传送指令

在 x86-64 的数据传送指令中，两个操作数不能都是指向内存位置，也就是说想要复制内存上的数据到指定内存位置，需要先加载到寄存器，再从寄存器保存到内存的指定位置

普通数据传送指令（movb、movw、movl、movq、movabsq）

- 源操作数：立即数、寄存器、内存位置
- 目的操作数：寄存器，内存位置

拓展数据传送指令（movzbw、movslq等）

- 源操作数：寄存器、内存位置
- 目的操作数：**只能在寄存器**



### 算数指令

比较特殊的是乘法指令，虽然都是 imul 指令，但一个操作数和两个操作数是不同指令

- imulq S D

  意思就是 S * D => D

- imulq S

  一个乘数是 S，另一个乘数是 rax 寄存器里的值，结果是 128 位的整数，高 64 位放在寄存器 rdx 里，低 64 位放在寄存器 rax 里

  S * R[%rax] => R[%rdx]:R[%rax]

  

除法指令只有单个操作数的版本

- idivq S

  S 是除数，128位的被除数在高 64 位存在 rdx，低 64 位在 rax 里，除法结果商存在 rax 里，余数存在 rdx 里

  如果不需要被除数只需要 64 位，可以先存在 rax 里

  - 有符号运算，ctlo 符号拓展 rax 的值，高位会设置在 rdx
  - 无符号运算，rdx 直接设置为 0

# 练习题

## 3.1

| 操作数         | 值    |
| -------------- | ----- |
| %rax           | 0x100 |
| 0x104          | 0xAB  |
| $0x108         | 0x108 |
| (%rax)         | 0xFF  |
| 4(%rax)        | 0xAB  |
| 9(%rax,%rdx)   | 0x11  |
| 260(%rcx,%rdx) | 0x13  |
| 0xFC(,%rcx,4)  | 0xFF  |
| (%rax,rdx,4)   | 0x11  |



## 3.2

movl   %eax, (%rsp)

movw  (%rax), %dx

movb   $0xFF, %bl

movb   (%rsp,%rdx,4), %dl

movq   (%rdx), %rax

movw   %dx, (%rax)



## 3.3

movb   $0xF, (%ebx)

寄存器 ebx 的值是 4 个字节，地址要 8 个字节

movl   %rax, (%rsp)

寄存器 rax 的值是 8 个字节，应该要用 movq

movw   (%rax), 4(%rsp)

mov 源操作数和目标操作数不能同时为内存上的数

movb   %al, %sl

没有 sl 寄存器，只有 sil

movq   %rax, $0x123

不能使用立即数当目标操作数，这里做题的时候犯了个错误把 $0x123 当成了直接寻址内存

实际上以 $ 开头的数就是立即数，需要记住这一点

movl   %eax, %rdx

源操作数的寄存器和目标操作数的寄存器不一样大

movb   %si, 8(%rbp)

寄存器 si 存储的是 2 字节的数据，应该用 movw



## 3.4

| src_t         | dest_t        | 指令                  |
| ------------- | ------------- | --------------------- |
| long          | long          | movq   (%rdi), %rax   |
|               |               | movq   %rax, (%rsi)   |
| char          | int           | movsbl   (%rdi), %eax |
|               |               | movl   %eax, (%rsi)   |
| char          | unsigned      | movsbl   (%rdi), %eax |
|               |               | movl   %eax, (%rsi)   |
| unsigned char | long          | movzbl   (%rdi), %rax |
|               |               | movq   %rax, (%rsi)   |
| int           | char          | movl   (%rdi), %eax   |
|               |               | movb   %al, (%rsi)    |
| unsigned      | unsigned char | movl   (%rdi), %eax   |
|               |               | movb   %al, (%rsi)    |
| char          | short         | movsbw   (%rdi), %ax  |
|               |               | movw   %ax, (%rsi)    |



## 3.5

```c
void decode1(long *xp, long *yp, long *zp) {
    long x = *xp;
    long y = *yp;
    long z = *zp;
   
    *yp = x;
    *zp = y;
    *xp = z;
}
```



## 3.6

| 表达式                        | 结果          |
| ----------------------------- | ------------- |
| leaq   6(%ax), %rdx           | 6 + x         |
| leaq   (%rax, %rcx), %rdx     | x + y         |
| leaq   (%rax, %rcx, 4), %rdx  | x + 4 * y     |
| leaq   7(%rax, %rax, 8), %rdx | 7 + 9 * x     |
| leaq   0xA(, %rcx, 4), %rdx   | 10 + 4 * y    |
| leaq   9(%rax, %rcx, 2), %rdx | 9 + x + 2 * y |



## 3.7

5 * x + 2 * y + 8 * z



## 3.8



| 指令                         | 目的                                                        | 值    |
| ---------------------------- | ----------------------------------------------------------- | ----- |
| addq   %rcx, (%rax)          | M[R[rax]] <= R[rcx] + M[R[rax]];0x100                       | 0x100 |
| subq   %rdx, 8(%rax)         | M[8 + R[rax]] <= M[8 + R[rax]] - 0x3;0x108                  | 0xA8  |
| imulq   $16, (%rax, %rdx, 8) | M[R[rax] + 8 * R[rdx]] <= 16 * M[R[rax] + 8 * R[rdx]];0x118 | 0x110 |
| incq   16(%rax)              | M[16 + R[rax]] <= 1 + M[16 + R[rax]];0x110                  | 0x14  |
| decq   %rcx                  | R[rcx] <= R[rcx] - 1;%rcx                                   | 0x0   |
| subq   %rdx, %rax            | R[rax] <= R[rax] - R[rdx];%rax                              | 0xFD  |



## 3.9

```assembly
shlq   4, %rax
sarq   %cl,%rax
```



## 3.10

```c
long arith2(long x, long y, long z) {
    long t1 = x | y;
    long t2 = t1 >> 3;
    long t3 = ~t2;
    long t4 = z - t3;
    return t4;
}
```



## 3.11

xor   %rdx, %rdx

A. 将寄存器 rdx 的值设置为 0

B. movq   $0, %rdx

C.  自己写代码编译看了下，用 mov 指令占用的字节数是7字节， xor 指令占用了 3 字节

``` assembly
test.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c2 00 00 00 00    mov    $0x0,%rdx
   7:   48 31 d2                xor    %rdx,%rdx
```



## 3.12

```assembly
uremdiv:
	movq   %rdx, %r8
	movq   %rdi, %rax
	xor    %rdx, %rdx
	divq   %rsi
	movq   %rax, (%r8)
	movq   %rdx, (%rcx)
	ret
```



## 3.13

A. a < b，因为使用的是 setl，有符号的，所以数据类型是 int 类型

B. a >= b  setge 是有符号的，所以数据类型是 short

C. a <= b  setbe 是无符号的，数据类型 unsigned char

D. a != b  setne 有可能是有符号，也有可能是无符号，所以数据类型可能有两种 long 和 unsigned long



## 3.14

A. long, a >= 0

B. short;unsigned short, a == 0

C.  unsigned char, a > 0

D. int, a <= 0



## 3.15

A. 4003fe

B. 400425

C. pop 400545, ja 400543

D. 400560



## 3.16

A.

```c
void cond(long a, long *p)
{
    if (p == 0) {
        goto do_nothing; 
    }
    //这个注意不要写反了，cmpq %rdi, (%rsi) => (%rsi) - %rdi
    if (*p >= a) {
        goto do_nothing;
    }
    *p = a;
do_nothing:
    return;
}
```

B. 因为 C 语言的 if 语句里用 && 连接了两个条件



## 3.17

A.

```c
long gotodiff_se(long x, long y)
{
    long result;
	if (x < y)
        goto x_lt_y;
    ge_cnt++;
    result = x - y;
    return result;
x_lt_y:
    lt_cnt++;
    result = y - x;
    return result;
}
```

B. 都差不多



## 3.18

```c
long test(long x, long y, long z) {
    long val = x + y + z;
    if (x < -3) {
		if (y >= z) {
            val = y * z;
        } else {
            val = x * y;
        }
    } else if (x > 2) {
        val = x * z;
    }
    return val;
}
```



## 3.19

A. 2 * (31 - 16) = 30

B. 30 + 16 = 46



## 3.20

A. / 右移实现除法

B. 

```assembly
arith:
	leaq 7(%rdi), %rax   //val = 7 + x
	testq %rdi, %rdi     //
	cmovns %rdi, %rax    //if x >= 0 then val = x
	sarq $3, %rax        //val = val >> 3
	ret
```



## 3.21

```c
long test(long x, long y) {
    long val = 8 * x;
    if (y > 0) {
        if (x >= y) {
            val = x & y;
        } else {
            val = y - x;
        }
    } else if (y <= -2) {
        val = x + y
    }
}
```



## 3.22

A. 12

B. 19



## 3.23

A. x 存在 %rax, y 存在 %rcx, n 存在 %rdx

B. 第 7 行在计算 x + y 的时候顺便加 1 了

C. 

```assembly
dw_loop:
	movq	%rdi, %rax	/* set result = x*/
	movq	%rdi, %rcx	/* y = x*/
	imulq	%rdi, %rcx	/* y = x * x */
	leaq	(%rdi, %rdi), %rdx	/* n = 2 * x */
.L2:
	leaq	1(%rcx, %rax), %rax	/* x = x + y + 1*/
	subq	$1, %rdx	/* n = n - 1*/
	testq	%rdx, %rdx
	jg		.L2		/* if n > 0 then goto L2*/
	rep; ret
```



## 3.24

```c
long loop_while(long a, long b) {
    long result = 1;
    while(a < b) {
        result = (a + b) * result;
        a = a + 1;
    }
}
```



## 3.25

```c
long loop_while2(long a, long b) {
    long result = b;
    while(b > 0) {
        result = result * a;
        b = b - a;
    }
}
```



## 3.26

A. jump to middle

B. 

```c
long fun_a(unsigned long x) {
    long val = 0;
    while(x != 0) {
        val = val ^ x;
        x = x >> 1;
    }
    return val & 0x1;
}
```

C. 计算x里有奇数个还是偶数个1





