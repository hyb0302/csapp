# 练习题

## 12.1

因为这个已连接描述符指向的文件表项中的引用计数还有1，被子进程的已连接描述符引用着，还没被回收



## 12.2

因为进程结束的销毁的时候会自动关闭已连接描述符



## 12.3

从select返回准备好的描述符0



## 12.4

因为 select 返回后会把 ready_set 的值设置成已经准备就绪的描述符集合，需要重新初始化成全部需要监听的描述符集合再调用 select 监听



## 12.5

因为子进程的描述符是一个副本，所以父子进程都要关闭属于它们自己的描述符，但是不同线程是共享的描述符，所以只要关闭一次就行



## 12.6

A. 

| 变量实例 | 主线程引用的？ | 对等线程0引用的？ | 对等线程1引用的？ |
| -------- | -------------- | ----------------- | ----------------- |
| ptr      | 是             | 是                | 是                |
| cnt      | 否             | 是                | 是                |
| i.m      | 是             | 否                | 否                |
| msgs.m   | 是             | 是                | 是                |
| myid.p0  | 否             | 是                | 否                |
| myid.p1  | 否             | 否                | 是                |

B. ptr、cnt、msgs 是共享的



## 12.7

| 步骤 | 线程 | 指令          | %rdx<sub>1</sub> | %rdx<sub>2</sub> | cnt  |
| ---- | ---- | ------------- | ---------------- | ---------------- | ---- |
| 1    | 1    | H<sub>1</sub> | -                | -                | 0    |
| 2    | 1    | L<sub>1</sub> | 0                | -                | 0    |
| 3    | 2    | H<sub>2</sub> | 0                | -                | 0    |
| 4    | 2    | L<sub>2</sub> | 0                | 0                | 0    |
| 5    | 2    | U<sub>2</sub> | 0                | 1                | 0    |
| 6    | 2    | S<sub>2</sub> | 0                | 1                | 1    |
| 7    | 1    | U<sub>1</sub> | 1                | 1                | 1    |
| 8    | 1    | S<sub>1</sub> | 1                | 1                | 1    |
| 9    | 1    | T<sub>1</sub> | 1                | 1                | 1    |
| 10   | 2    | T<sub>2</sub> | 1                | 1                | 1    |



## 12.8

A. 安全

B. 不安全

C. 安全



## 12.9

A. 必需

B. 不必需

C. 不必需



## 12.10





## 12.11

| 线程（t）                 | 1    | 2    | 4    |
| ------------------------- | ---- | ---- | ---- |
| 核（p）                   | 1    | 2    | 4    |
| 运行时间（T<sub>p</sub>） | 12   | 8    | 6    |
| 加速比（S<sub>p</sub>）   | 1    | 1.5  | 2    |
| 效率（E<sub>p</sub>）     | 100% | 75%  | 50%  |



## 12.12

因为P(&mutex) 减一之后，再进来这个函数会在这等待



## 12.13

会跟主线程引起竞争，有可能创建线程后，还没进入子线程例程里就释放了



## 12.14

A. 直接把数字传过去，Pthread_create(&tid[i], NULL, thread, i);

B. 这种方法好处就是不用特地申请内存，也就不用释放内存；不好的地方就是假设指针至少和 int 一样大，以前的机子不一定是这样