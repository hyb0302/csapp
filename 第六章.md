# 笔记

## 存储技术

### 随机访问存储器 RAM

#### SRAM

每个 bit 需要用 6 个晶体管组成的电路存储，晶体管多，单位存储容量就小，造价也更贵，但是速度很快，用于 cpu 的寄存器和 cache

#### DRAM

每个 bit 用一个电容和一个晶体管存储，因为电容的电会流失，所以需要定时读出刷新，造价便宜，用于内存

### 磁盘存储

盘片 platter

表面 surface

主轴 spindle

磁道 track

扇区 sector

柱面 cylinder



## 高速缓存存储器

### 直接映射高速缓存

每个组里只有一行缓存块

1. 组选择

   

2. 行匹配

3. 字选择



# 练习题

## 6.1

| 组织   | r    | c    | b<sub>r</sub> | b<sub>c</sub> | max(b<sub>r</sub>, b<sub>c</sub>) |
| ------ | ---- | ---- | ------------- | ------------- | --------------------------------- |
| 16x1   | 4    | 4    | 2             | 2             | 2                                 |
| 16x4   | 4    | 4    | 2             | 2             | 2                                 |
| 128x8  | 16   | 8    | 4             | 3             | 4                                 |
| 512x4  | 32   | 16   | 5             | 4             | 5                                 |
| 1024x4 | 32   | 32   | 5             | 5             | 5                                 |



## 6.2

2 x 2 x 10000 x 400 x 512 = 8.192GB



## 6.3

T<sub>access</sub> = T<sub>avg seek</sub> + T<sub>avg rotation</sub> + T<sub>avg transfer</sub>

T<sub>avg seek</sub> = 8 ms

T<sub>avg rotation</sub></sub> = 60 / 15000  * 1000 * 1 / 2  = 2 ms

T<sub>avg transfer</sub> = 60 / 15000 x 1 / 500 * 1000 = 0.008 ms

T<sub>access</sub> = 8 + 2 + 0.008 = 10.008 ms



## 6.4

1MB 的文件需要读 2000 个 512 字节的逻辑块（这里 M 按照 2<sup>20</sup> 算是要 2048 个，按照 10<sup>6</sup> 算是 1953 多个，不知道为啥答案上写着 2000，那就当作 2000 算吧，影响不大）



T<sub>avg seek</sub> = 5 ms

T<sub>max rotation</sub> = 60 / 10000 * 1000 = 6 ms

T<sub>avg rotation</sub> = 1 / 2 * T<sub>max rotation</sub> = 3 ms

T<sub>avg transfer</sub> = 60 / 10000 x 1 / 1000 * 1000 = 0.006 ms



A. T<sub>access</sub> = T<sub>avg seek</sub> + T<sub>avg rotation</sub> + 2 x T<sub>max rotation</sub> = 5 + 3 + 2 * 6 = 20 ms

这里因为是最好情况，数据都是顺序排放的，所以需要定位到第一个扇区后，因为要读 2000 个逻辑块，并且一个磁道的平均扇区数是 1000，磁头需要完整转两圈，所以要加上两次最大旋转的时间

B. T<sub>access</sub> = 2000 x (T<sub>avg seek</sub> + T<sub>avg rotation</sub>) = 2000 x 8 = 16000 ms

这题可以看出，磁盘碎片太多还是很影响速度的



## 6.5

128PB 转换成 128 000 000 GB

A. 128000000 / 0.47 / 3600 / 24 / 365 ≈ 8.64 年

B. 128000000 / 0.303 / 3600 / 24 / 365  ≈ 13.4 年

B. 128000000 / 20 / 365 ≈ 17534 年



## 6.6 下次算

500 美元买 1 PB 的硬盘，每 GB 售价就是 500 / 1000000 = 0.0005

只看 2005 年到 2015 年的价格 5 / 0.03 = 166

0.0005 = 0.03 * (1 + )

0.03 / 0.0005 = 



## 6.7

```c
int sumarry3d(int a[N][N][N])
{
    int i, j, k sum = 0;
    
    for (k = 0; k < N; k++) {
    	for (i = 0; i < N; i++) {
        	for (j = 0; j < N; j++) {
        		sum += a[k][i][j];
    		}
    	}
    }
    return sum;
}
```



## 6.8

clear1 > clear2 > clear3

clear3 函数因为是跳着最外层结构体数组循环的，所以空间局部性最差

clear1 比 clear2 函数空间局部性好在是先循环完 vel 再循环 acc，结构体内部 vel 数组是存在顺序相邻的内存空间里



## 6.9

| 高速缓存 | m        | C                | B              | E        | S    | t        | s        | b          |
| -------- | -------- | ---------------- | -------------- | -------- | ---- | -------- | -------- | ---------- |
|          | 地址位数 | 缓存大小（字节） | 块大小（字节） | 组内行数 | 组数 | 标记位数 | 组索引数 | 块偏移位数 |
| 1        | 32       | 1024             | 4              | 1        | 256  | 22       | 8        | 2          |
| 2        | 32       | 1024             | 8              | 4        | 32   | 24       | 5        | 3          |
| 3        | 32       | 1024             | 32             | 32       | 1    | 27       | 0        | 5          |

