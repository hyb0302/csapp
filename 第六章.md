# 笔记

## 存储技术

### 随机访问存储器 RAM

#### SRAM

每个 bit 需要用 6 个晶体管组成的电路存储，晶体管多，单位存储容量就小，造价也更贵，但是速度很快，用于 cpu 的寄存器和 cache

#### DRAM

每个 bit 用一个电容和一个晶体管存储，因为电容的电会流失，所以需要定时读出刷新，造价便宜，用于内存

### 磁盘存储

盘片 platter

表面 surface

主轴 spindle

磁道 track

扇区 sector

柱面 cylinder



## 高速缓存存储器

### 直接映射高速缓存

每个组里只有一行缓存块

1. 组选择

   利用地址中间的**组索引**，解释为对应组下标的无符号数

2. 行匹配

   通过地址中的**标记位**寻找组里相同标记位的那行个块，同时要看有效位是否为 1，才能决定缓存命中

3. 字选择

   通过地址中的**块偏移**找到块中的某个地方，从这个地方开始读取所需要的数据

4. 缓存替换策略

​		因为只有组里只有一行，所以缓存没命中的话直接替换掉原有的就行



### 组相联高速缓存

每个组的行数是 1 < E < C / B，也就是大于【1】行小于【缓存大小 除以 高速缓存块大小】

1. 组选择

   与直接映射一样

2. 行匹配

   与直接映射差不多，区别就是组相联有多个行，可能需要匹配多次才能知道组里有没有相同标记位的内存块（缓存过的数据）

3. 字选择

   跟直接映射一样

4. 缓存替换策略

   如果满了需要替换，有几种策略：随机、最不常使用（LFU）、最近最少使用（LRU）

   这些需要硬件支持



### 全相联高速缓存

只有一个组，组的行数就是 C / B 【缓存大小 除以 高速缓存块大小】

这样子其实就是没有了组的概念，地址里也就没有哪些位被视作组索引位了，全都是由 标记位 和 块偏移 组成

1. 组选择

​		无，因为只有一个组

2. 行匹配和字选择

   跟组相联一样

到这里我怎么感觉，这个全相联跟直接映射的样子看起来差不多，只不过行分割全相联用的是组里的行，直接映射用的是组



### 写的问题

当要修改一个已经缓存了的字

- 写命中，也就是数据还在高速缓存里，这时有两种方式修改

  - 直写 write through

    立刻将数据写入到存储层次结构中紧接着的低一层中

  - 写回 write back

    每个高速缓存行多维护一个修改位，等这个高速缓存行要被替换掉的时候再写入紧接着的低一层中

- 写不命中，该数据已经被替换出高速缓存了，这时有两种方式处理

  - 写分配 write-allocate

    加载这块数据到高速缓存中，然后更新这个高速缓存块

  - 非写分配 not-write-allocate

    不加载数据到高速缓存，直接写到低一层中

  

  如果写命中的情况下方式时【直写】的话，是采用【非写分配】

  如果写命中的情况下方式时【写回】的话，采用【写分配】

  



# 练习题

## 6.1

| 组织   | r    | c    | b<sub>r</sub> | b<sub>c</sub> | max(b<sub>r</sub>, b<sub>c</sub>) |
| ------ | ---- | ---- | ------------- | ------------- | --------------------------------- |
| 16x1   | 4    | 4    | 2             | 2             | 2                                 |
| 16x4   | 4    | 4    | 2             | 2             | 2                                 |
| 128x8  | 16   | 8    | 4             | 3             | 4                                 |
| 512x4  | 32   | 16   | 5             | 4             | 5                                 |
| 1024x4 | 32   | 32   | 5             | 5             | 5                                 |



## 6.2

2 x 2 x 10000 x 400 x 512 = 8.192GB



## 6.3

T<sub>access</sub> = T<sub>avg seek</sub> + T<sub>avg rotation</sub> + T<sub>avg transfer</sub>

T<sub>avg seek</sub> = 8 ms

T<sub>avg rotation</sub></sub> = 60 / 15000  * 1000 * 1 / 2  = 2 ms

T<sub>avg transfer</sub> = 60 / 15000 x 1 / 500 * 1000 = 0.008 ms

T<sub>access</sub> = 8 + 2 + 0.008 = 10.008 ms



## 6.4

1MB 的文件需要读 2000 个 512 字节的逻辑块（这里 M 按照 2<sup>20</sup> 算是要 2048 个，按照 10<sup>6</sup> 算是 1953 多个，不知道为啥答案上写着 2000，那就当作 2000 算吧，影响不大）



T<sub>avg seek</sub> = 5 ms

T<sub>max rotation</sub> = 60 / 10000 * 1000 = 6 ms

T<sub>avg rotation</sub> = 1 / 2 * T<sub>max rotation</sub> = 3 ms

T<sub>avg transfer</sub> = 60 / 10000 x 1 / 1000 * 1000 = 0.006 ms



A. T<sub>access</sub> = T<sub>avg seek</sub> + T<sub>avg rotation</sub> + 2 x T<sub>max rotation</sub> = 5 + 3 + 2 * 6 = 20 ms

这里因为是最好情况，数据都是顺序排放的，所以需要定位到第一个扇区后，因为要读 2000 个逻辑块，并且一个磁道的平均扇区数是 1000，磁头需要完整转两圈，所以要加上两次最大旋转的时间

B. T<sub>access</sub> = 2000 x (T<sub>avg seek</sub> + T<sub>avg rotation</sub>) = 2000 x 8 = 16000 ms

这题可以看出，磁盘碎片太多还是很影响速度的



## 6.5

128PB 转换成 128 000 000 GB

A. 128000000 / 0.47 / 3600 / 24 / 365 ≈ 8.64 年

B. 128000000 / 0.303 / 3600 / 24 / 365  ≈ 13.4 年

B. 128000000 / 20 / 365 ≈ 17534 年



## 6.6 下次算

500 美元买 1 PB 的硬盘，每 GB 售价就是 500 / 1000000 = 0.0005

只看 2005 年到 2015 年的价格 5 / 0.03 = 166

0.0005 = 0.03 * (1 + )

0.03 / 0.0005 = 



## 6.7

```c
int sumarry3d(int a[N][N][N])
{
    int i, j, k sum = 0;
    
    for (k = 0; k < N; k++) {
    	for (i = 0; i < N; i++) {
        	for (j = 0; j < N; j++) {
        		sum += a[k][i][j];
    		}
    	}
    }
    return sum;
}
```



## 6.8

clear1 > clear2 > clear3

clear3 函数因为是跳着最外层结构体数组循环的，所以空间局部性最差

clear1 比 clear2 函数空间局部性好在是先循环完 vel 再循环 acc，结构体内部 vel 数组是存在顺序相邻的内存空间里



## 6.9

| 高速缓存 | m        | C                | B              | E        | S    | t        | s        | b          |
| -------- | -------- | ---------------- | -------------- | -------- | ---- | -------- | -------- | ---------- |
|          | 地址位数 | 缓存大小（字节） | 块大小（字节） | 组内行数 | 组数 | 标记位数 | 组索引数 | 块偏移位数 |
| 1        | 32       | 1024             | 4              | 1        | 256  | 22       | 8        | 2          |
| 2        | 32       | 1024             | 8              | 4        | 32   | 24       | 5        | 3          |
| 3        | 32       | 1024             | 32             | 32       | 1    | 27       | 0        | 5          |



## 6.10

| i    | x    | 7    |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 1    | 1    | 1    |
| 2    | 1    | 1    |
| 3    | 1    | 1    |
| 4    | 0    | 0    |
| 5    | 1    | 1    |
| 6    | 1    | 1    |
| 7    | 1    | 1    |

x 和 y 的命中率都是 75%



## 6.11

假设地址总位数是 m

A. 2<sup>m-s</sup> 个字节也就是 2<sup>t</sup>个块，这个问题一开始没看懂啥意思，

我猜测是问，数组片加载到高速缓存里，会在高速缓存里占多少块（数组片也就是一组相邻的数据，相邻的因为最高地址位是作为组索引）

数组片最大能占到一组的数据块数，也就是 2 <sup>t</sup> 块，一开始写的是 2<sup>m-s</sup> 块，后来才发现这个的单位是字节，以块为单位，数字应该是 2<sup>m-s-b</sup> 个也就是 2<sup>t</sup>个块

B. 

m=32, s=9, b=5, t=32-9-5=18

最大下标的地址：000000000 000000001000000000 00000，从这里可以分析出，在组索引在最前面的情况下，就算把 数组里 4096 个数据都引用一遍，都是映射到高速缓存的第一组，由于一组只有一行，所以答案就是最大数量是一个数据块 32 字节

这也能看出利用地址高位做组索引不能充分利用高速缓存



## 6.12

| 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| CT   | CT   | CT   | CT   | CT   | CT   | CT   | CT   | CI   | CI   | CI   | CO   | CO   |



## 6.13

A.

00001110001 101 00

| 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 0    |

B.

| 参数               | 值   |
| ------------------ | ---- |
| 块偏移（CO）       | 0x00 |
| 组索引（CI）       | 0x5  |
| 标记（CT）         | 0x71 |
| 高速缓存是否命中？ | 是   |
| 返回的高速缓存字节 | 0xB  |



## 6.14

A.

0000 1101 1101 0101

01101110 101 01

| 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 0    | 1    | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 1    |

B.

| 参数               | 值   |
| ------------------ | ---- |
| 块偏移（CO）       | 0x1  |
| 组索引（CI）       | 0x5  |
| 标记（CT）         | 0x6E |
| 高速缓存是否命中？ | 否   |
| 返回的高速缓存字节 | -    |



## 6.15

A.

0001 1111 1110 0100

11111111 001 00

| 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 1    | 0    | 0    |

B.

| 参数               | 值   |
| ------------------ | ---- |
| 块偏移（CO）       | 0x0  |
| 组索引（CI）       | 0x1  |
| 标记（CT）         | 0xFF |
| 高速缓存是否命中？ | 否   |
| 返回的高速缓存字节 | -    |



## 6.16

0011 0010 011 00 => 0x64C

0011 0010 011 01=> 0x64D

0011 0010 011 10=> 0x64E

0011 0010 011 11=> 0x64F



