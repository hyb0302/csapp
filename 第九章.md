# 练习题

## 9.1

| 虚拟地址位数（n） | 虚拟地址数（N）       | 最大可能的虚拟地址          |
| ----------------- | --------------------- | --------------------------- |
| 8                 | 2<sup>8</sup> = 256   | 255                         |
| 16                | 2<sup>16</sup> = 64K  | 64K - 1                     |
| 32                | 2<sup>32</sup> = 4G   | 2<sup>32</sup> - 1 = 4G - 1 |
| 48                | 2<sup>48</sup> = 256T | 256T - 1                    |
| 64                | 2<sup>64</sup> = 16E  | 16E - 1                     |



## 9.2

| n    | P = 2<sup>p</sup> | PTE数量        |
| ---- | ----------------- | -------------- |
| 16   | 4K                | 16             |
| 16   | 8K                | 8              |
| 32   | 4K                | 2<sup>20</sup> |
| 32   | 8K                | 2<sup>19</sup> |



## 9.3

| 页面大小 | 虚拟页号 | 虚拟页偏移量 | 物理页号 | 物理页偏移量 |
| -------- | -------- | ------------ | -------- | ------------ |
| P        | VPN位数  | VPO位数      | PPN位数  | PPO位数      |
| 1KB      | 22       | 10           | 14       | 10           |
| 2KB      | 21       | 11           | 13       | 11           |
| 4KB      | 20       | 12           | 12       | 12           |
| 8KB      | 19       | 13           | 11       | 13           |



## 9.4

虚拟地址 0x03d7

0000 0011 1101 0111

A. 虚拟地址格式

| 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 0    | 1    | 0    | 1    | 1    | 1    |

因为页大小是 64 字节，需要 6 位 2 进制数寻址

虚拟页内偏移为低六位 00 0011 11**01 0111**



要在 TLB 里寻找页表缓存项，可以这么解读虚拟地址：

TLB 因为只有四组，需要 2 位作为索引寻址，00 0011 **11**01 0111

剩下位数就是 TLB 的标志位 **00 0011** 1101 0111



如果在 TLB 里找不到缓存项，要从内存里获取页表项

**00 0011 11**~~01 0111~~

除了低六位，如果有多级的话则会通过前面这 8 位确定页表

如果有四级页表的话，则第一级页表项索引为 **00** 0011 11~~01 0111~~

第二级 00 **00**11 11~~01 0111~~

第三级 00 00**11** 11~~01 0111~~

第四级 00 0011 **11**~~01 0111~~



**从这里可以看出，虚拟地址一直都是虚拟地址，根据要查找的地方不同（TLB/多级页表），解读这个地址的方式也不同**



B. 

| 参数                | 值   |
| ------------------- | ---- |
| VPN                 | 0xF  |
| TLB 索引            | 0x3  |
| TLB 标记            | 0x3  |
| TLB 命中？（是/否） | 是   |
| 缺页？（是/否）     | 否   |
| PPN                 | 0xD  |



C. 物理地址格式

0xD（PPN、6位） 和 0x17（VPO、6位） 结合

001101 010111

| 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 1    | 1    |

D. 物理内存引用

| 参数                | 值   |
| ------------------- | ---- |
| 字节偏移            | 0x3  |
| 缓存索引            | 0x5  |
| 缓存标记            | 0xD  |
| 缓存命中？（是/否） | 是   |
| 返回得缓存字节      | 0x1D |



## 9.5

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>


void mmapcopy(int fd, int size) 
{
    char* bufp;
    bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
    write(1, bufp, size);
    return;
}

int main(int argc, char* argv[])
{
    int fd;
    struct stat stat;
    
    fd = open(argv[1], O_RDONLY, 0);
    fstat(fd, &stat);
    mmapcopy(fd, stat.st_size);
    exit(0);
}
```

